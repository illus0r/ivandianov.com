<!DOCTYPE html><html class=""><head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Электростатическое взаимодействие частиц · Ivan Dianov</title>
    <link rel="stylesheet" href="/styles.css">
    <!-- FIXME check if it is needed -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.css">
    <link id="favicon" rel="icon">
<script>
		let w = 3
		let h = 5
    let svg = `<svg width="128" height="128" xmlns="http://www.w3.org/2000/svg" viewBox="1 0 ${w*2} ${h}"	>`
		for(let x = 0; x < w; x++) {
			for(let y = 0; y < h; y++) {
				let color = Math.random() > 0.5 ? "#000" : "#fff"
				svg += `<rect x="${w-x}" y="${y}" width="1" height="1" fill="${color}"/>`
				svg += `<rect x="${w+x}" y="${y}" width="1" height="1" fill="${color}"/>`
			}
		}

    svg+=`</svg>`
console.log('svg:',svg)

    document.getElementById("favicon").setAttribute("href", `data:image/svg+xml,${encodeURIComponent(svg)}`)
</script>

    <!-- Yandex.Metrika counter -->
<script type="text/javascript">
   (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
   m[i].l=1*new Date();
   for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
   k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
   (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

   ym(94453443, "init", {
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true,
        webvisor:true
   });
</script>
<noscript></noscript></head><body><div><img src="/.11ty/image/?src=https%3A%2F%2Fmc.yandex.ru%2Fwatch%2F94453443&amp;width=1&amp;format=webp&amp;via=transform" style="position:absolute; left:-9999px;" alt="" loading="lazy" decoding="async" width="1" height="1"></div>
<!-- /Yandex.Metrika counter -->




    <header>
  <div class="nav-menu">
    
    
    
        <a class="nav-item" href="/">
          Иван Дианов
        </a>
    
      
        
        
        <a class="nav-item" href="/">
          Дизайн
        </a>
        
      
    
      
        
        
        <a class="nav-item" href="/ru/show/">
          Медиа-арт
        </a>
        
      
    
      
        
        
        <a class="nav-item" href="/ru/tutor/">
          Обучение
        </a>
        
      
    
      
        
        
        <a class="nav-item" href="/ru/about/">
          Про меня
        </a>
        
      
    
    
    
    
    
    
		
      
		
        
		
      
		
    
    
		
      
		
      
		
  </div>
</header>


    <main role="main" class="wrap prose">
        
<article class="text" role="main">
    <div class="post-header">
		<div class="meta">
    
		
	
	


<span class="progress" style="--progress: 90deg;"></span> Черновик

    </div>
    <h1 class="post-name"><span class="dance-dance"><span>Э</span><span>л</span><span>е</span><span>к</span><span>т</span><span>р</span><span>о</span><span>с</span><span>т</span><span>а</span><span>т</span><span>и</span><span>ч</span><span>е</span><span>с</span><span>к</span><span>о</span><span>е</span><span> </span><span>в</span><span>з</span><span>а</span><span>и</span><span>м</span><span>о</span><span>д</span><span>е</span><span>й</span><span>с</span><span>т</span><span>в</span><span>и</span><span>е</span><span> </span><span>ч</span><span>а</span><span>с</span><span>т</span><span>и</span><span>ц</span></span></h1>
    </div>
    <section class="post-content">
        <p>Так вот всё началось, когда я начал работать над коммерческим проектом, где нужно было из чёрно-белых видосов делать анимированные изображения из точек. Очень кстати пришлось то, что в генклубе sleeping подсказала ссылку на похожую работу. Там котик из точек складывается и под этим котиком были ссылки на реализацию. Реализация была такая:</p>
<p>Во-первых, у нас все частицы друг от друга отталкиваются. Это электростатическое взаимодействие. А во-вторых, они притягиваются к белым пикселям видоса, то есть там, где у нас светлое изображение, Тогда слетается больше частиц.</p>
<p>Изменяя, Ну то есть в можно настроить вид этого взаимодействия, управляя коэффициентами отталкивания и коэффициентом. притяжения к пикселям видео, если к видео притягиваются сильно то Будут в местах засвета будут скученности частиц, они будут друг друга толкать. а если Уменьшить то, наоборот на видео они будут практически не реагировать и заполнять будут экран более-менее равномерно.</p>
<p>Оставалось посчитать силы взаимодействия между частицами. Но тут была проблема, потому что частиц должно быть много, если бы их было мало, то мы бы брали каждую частицу. Мерили бы расстояние от неё до всех остальных частиц и по формуле вычисляли бы силу взаимодействия, складывали бы все эти маленькие силочки и получали общую силу, которая действует на частицу. Итак для каждой частицы То есть если вы очистить было 10, то нужно было бы произвести 100 измерений длины расстояние между ними, если бы частиц было тысяча, то миллионы смирений количество измерения, оно увеличивается пропорционально квадрату частиц. То есть это очень медленный вариант. Если частиц много нужно было как-то это оптимизировать.</p>
<p>Тогда я решил пожертвовать точностью, во-первых, я решил взять все частицы и нарисовать их на текстуре. Поставить на текстуре много точек, там, где все эти частицы находятся, а потом уменьшить разрешение этой частицы. Ой это текстуры век жили. Это очень легко делается буквально одной строчкой, кода это называется</p>
<p>теперь вместо того, чтобы Считать расстояние от частицы до каждой другой частицы нужно посчитать расстояние от частицы до каждого пикселя этой текстуры с низким разрешением. Проблема в том, что А ну, там, где мало точек попало в пиксель низкого разрешения. Там у нас будет бледный пиксель, там, где много, там будет яркий пиксель, то есть мы яркость пикселя умножаем на количество на его площадь. и получаем тот заряд Который раскидан по этому пилю. Если пиксель находится от нашей частицы далеко, то мы можем просто считать, что его координаты равны центру этого пикселя, то есть мы выбрасываем информацию о всех содержащих. об их конкретных расположениях усредняемых</p>
<p>И тут такой компромисс, Какой выбрать размер пикселя? То есть, какое разрешение этой текстуры сделать, если разрешение довольно высокое, то будет хорошая точность, но придётся считать расстояние до большого количества пикселей это замедлит. Выполнение программы, если мы возьмём крупные пиксели, то всё быстро посчитается, но при этом частицы будут лететь. Кто куда?</p>
<p>И тут пригождается другое свойство мигмефов. Это то, что они создаются пачкой, они создаются с сразу пачкой для разных размеров от одного пикселя до Копии изображения мы можем потом брать считывать пиксель из нужной текстуры из этой пачки. Мы можем с помощью Если это ноль, то мы сэмплим исходное изображение, если это единица, то изображение в два раза меньше. Разрешения и так далее вплоть до одного пикселя.</p>
<p>Остаётся только измерять расстояние до середины этого пикселя, если оно большое То всё-таки, если оно очень близко располагается к нашей точке, то начинает влиять уже вот вот это пренебрежение координатами зарядов, разбросанных по пикселю начинает влиять заметно. и приходится А уменьшать размер пикселя, то есть уменьшает левела в details, двигаться к нулю и практически вплоть до исходного изображения. Я путём экспериментов пришёл к тому, что мы должны добиться того, что размер пикселя. Я имею в виду пиксель пикселя текстуры пониженного разрешения, измеренного в пикселях исходной текстуры, что размер этого пикселя должен быть? В где-то в пять раз меньше, чем расстояние. от частицы до середины этого пикселя</p>
<p>Всё, Это вроде бы пыталась как-то работать, Но работала кривовато. Все пиксели дёргались, и они расползались всё время за края экрана было непонятно. Это правильно вообще или неправильно. Поэтому я сделал два дополнения, во-первых. Я стал рендерить пиксель на вот эту текстуру не частицу на эту текстуру не одним пикселем, а размытым пятном пикселей. Такой размытый кружочек он добавлял плавности, Потому что если частица оказывалась на границе двух. Квадратов двух пикселей, то она влияла, на каждый из них это давало более плавное взаимодействие. А с тем, что у нас частицы вылетали за края? Мне помогли. Формулы я не помню, как это называется? Модульная математика или блин, не помню. Ну, в общем, если мы как будто Соединяем, а края экрана правые слева верхние. То есть, топология Тора если мы уйдём вправо мы придём слева. То есть между двумя частицами можно поверить расстояние? Как будто бы они находятся не на квадрате крана, А на этом Торе есть. Ну то есть формула, она немножко отличается. Там добавляется пару условий, но она довольно просто Таким образом мы можем вычислять расстояние между пикселями и также Вектор от одного пикселя до другого с учётом того, что они не на квадрате.</p>
<p>Я до этого говорил о том, что мы делаем мепмапы и Сэмплим текстуру, в которую рендерится все частицы, но то же самое мы делаем из текстуры видео. Мы тоже Превращаем её в пачку текстур пониженного разрешения и также их сам прям только знак у с коэффициента другой, если к первому От первых они отталкиваются, то ко второму не притягивается.</p>
<p>И после этих двух изменений оно вдруг резко заработало. То есть я не мог поверить своим глазам, что нас сразу просто произошёл какой-то качественный скачок и анимация стала плавной перестала дёргаться. и всё заработало. Я прикрутил. Вот видео не из файла, А через веб-камеру тоже оказалось нетрудно. И всё стало классно анимироваться. Я рассказал один клубе про эту штуку, и мне тут же сказали, что это Очень напоминает алгоритм барнетта. Видимо я не знаю, тогда один человек или два, но это алгоритм, который Ну то есть как раз для решения на базе проблем. Когда у нас много-много частиц взаимодействует все со всеми. К сожалению я не оказался первооткрывателем этого алгоритма его придумали ещё до моего рождения, но всё равно было приятно такое велосипед изобрести.</p>

    </section>
</article>

<script src="https://utteranc.es/client.js" repo="illus0r/ivandianov.com" issue-term="pathname" label="blog-comment" theme="github-light" crossorigin="anonymous" async="">
</script>

    </main>

    <footer>
  <section class="copyright">© <a href="/">Иван Дианов</a> 2021—∞ ·
		<a href="/ru/blog/">Блог</a> ·
		<a href="https://t.me/ivandianov">Канал в телеге</a> про генеративный арт, алгоритмы и жизнь</section>
</footer>


    <script src="/assets/js/dance-dance.js" type="module"></script>
    


</body></html>