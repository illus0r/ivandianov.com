<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom">
	<title></title>
	<subtitle></subtitle>
	<link href="https://ivandianov.com/feed.xml" rel="self"/>
	<link href="https://ivandianov.com/"/>
	
	<updated>2022-12-01T17:48:58Z</updated>
	<id>https://ivandianov.com/</id>
	<author>
		<name xml:lang="en">Ivan Dianov</name>
		<name xml:lang="ru">Иван Дианов</name>
		<email>zor667@gmail.com</email>
	</author>
	
	<entry xml:lang="ru">
		<title>Иваноматы — клеточные автоматы с нарастающим разрешением</title>
		<link href="https://ivandianov.com/ru/ivanomata/"/>
		<updated>2022-11-21T01:39:00Z</updated>
		<id>https://ivandianov.com/ru/ivanomata/</id>
		<content type="html">&lt;p&gt;&lt;img src=&quot;https://ivandianov.com/assets/media/2022-11-26-15-22-41.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Иваноматы — клеточные автоматы с нарастающим разрешением. Вроде бы, таких раньше не было, поэтому назвал в свою честь. Если вы что-то похожее уже видели&lt;!-- до ноября 2021 года--&gt;, дайте знать, перееименую.&lt;/p&gt;
&lt;p&gt;Как-то раз читал на ночь книжку «The Algorithmic Beauty of Plants»  &lt;!--про L-системы. Оказывается, их придумал биолог Аристид Линденмайер для описания структуры растений, буква L именно от его фамилии. И от генеративных грамматик Хомского они отличаются тем, что все правила применяются к токенам одновременно. Прямо как в шейдерах. А у Хомского — по очереди, как в JS. Шок. Оказалось--&gt; и понял, что клеточные автоматы — частный случай контекстно-зависимых L-систем! А ведь я два года пытался и не мог придумать, как сделать генеративные грамматики двумерными.&lt;/p&gt;
&lt;p&gt;Так вдохновился, что следующим утром написал прототип.&lt;/p&gt;
&lt;h1&gt;Как работает&lt;/h1&gt;
&lt;p&gt;Клеточному автомату нужны правила, по которым клетки меняют цвета.&lt;/p&gt;
&lt;p&gt;Цветов у нас всего два: ■ и □. Чтобы найти новый цвет клетки, посмотрим, какого цвета она сама и её четыре соседа. Возможны 32 комбинации:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ivandianov.com/assets/media/2022-11-26-13-59-46.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;!-- https://editor.p5js.org --&gt;
&lt;p&gt;Каждой из этих комбинаций сопоставим цвет, в который перекрасим центральную клетку, это и будут наши правила. Например, такие:&lt;/p&gt;
&lt;p :=&quot;&quot; class=&quot;caption&quot;&gt;&lt;img src=&quot;https://ivandianov.com/assets/media/2022-11-26-14-26-13.png&quot; alt=&quot;&quot;&gt;
Это один из 2&lt;sup&gt;32&lt;/sup&gt; = 4 294 967 296 возможных вариантов правил&lt;/p&gt;
&lt;!-- https://editor.p5js.org/illus0r/sketches/myfquQUaF --&gt;
&lt;p&gt;Дальше просто. Берём табличку 4×4 клетки, рандомно заполняем □ и ■.&lt;/p&gt;
&lt;p&gt;Проходимся по ней правилами, находим новые цвета для каждой ячейки. Обратите внимание, как центральная клетка заштрихованного участка использовала подходящее правило, чтобы узнать свой новый цвет.&lt;/p&gt;
&lt;p&gt;И, наконец, увеличиваем разрешение таблицы: каждую клетку делим на четыре.&lt;/p&gt;
&lt;p :=&quot;&quot; class=&quot;caption&quot;&gt;&lt;img src=&quot;https://ivandianov.com/assets/media/2022-11-26-15-11-26.png&quot; alt=&quot;&quot;&gt;
На третьей картинке получилось непонятно, разделились чёрные клетки или нет. Поверьте мне, что разделились. Не переделывать же картинку.&lt;/p&gt;
&lt;!-- https://www.figma.com/file/abzo0bhPE5EJIuaZtJgWEd/Untitled?node-id=2%3A404&amp;t=XQ7fThdoqwVCctyV-0 --&gt;
&lt;p&gt;Повторяем процедуру несколько раз. Будет получаться что-то такое:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ivandianov.com/assets/media/ivanomata.gif&quot; alt=&quot;&quot; :=&quot;&quot; style=&quot;width:512px;image-rendering: pixelated;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Или такое:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ivandianov.com/assets/media/ivanomata2.gif&quot; alt=&quot;&quot; :=&quot;&quot; style=&quot;width:512px;image-rendering: pixelated;&quot;&gt;&lt;/p&gt;
&lt;!-- https://bit.ly/3EDBkXq --&gt;
&lt;p&gt;Дальше можно придумать правила раскрашивания, совмещать результаты работы нескольких автоматов с разными правилами, менять правила на полдороге, накладывать картинку на её предыдущие итерации, веселиться по-полной!&lt;/p&gt;
&lt;video controls&gt;
  &lt;source src=&quot;https://ivandianov.com/assets/media/ivanomata-oculus.mp4&quot; type=&quot;video/mp4&quot;&gt;
&lt;/video&gt;
&lt;p&gt;Одна печаль, в 3д иваноматы совсем не такие прикольные.&lt;/p&gt;
&lt;!-- Чтобы её преобразовать, нам понадобятся правила. Они будут делить исходную клетку на 4 дочерних клетки и задавать цвета этим квадрантам исходя из цветов исходной клетки и её соседей. В отличие от игры Конвея будем рассматривать только 4 соседних клетки (если выражаться заумно, это соседство фон Неймана).

Ещё одно отличие от Конвея — у него всё равно, с какой стороны находятся соседи. А для нас важно.

То есть жизнь будет идти по правилам:

    n0, n1, n2, n3, n4 → color
    ↑   ↑
    |   Цвета четырёх соседей
    |
    Свой цвет

Получается вот так:
TODO


https://t.me/ivandianov/264

Если обрабатывать 8 соседних клеток (соседство Мура), а не 4 (соседство фон Неймана).

Выходит много мелкого мусора, пока что вернул, как было.



Таким образом, число клеток на каждом шаге будет увеличиваться в 4 раза.

Сколько же разных правил возможно, если клетка может быть либо жива, либо мертва?

Для задания правил, нам надо перебрать все возможные варианты правой части. Оказывается, для этого надо будет записать 

2 * 2 * 2 * 2 * 2 = 32 строчек вида

    0, 0, 0, 0, 0 → 0
    0, 0, 0, 0, 1 → 1
    0, 0, 0, 1, 0 → 1
    0, 0, 0, 1, 1 → 1
    0, 0, 1, 0, 0 → 0
    0, 0, 1, 0, 1 → 0
    0, 0, 1, 1, 0 → 1
    …

Если перебрать все возможные варианты правой части такого свода правил (левая всегда будет оставаться неизменной), получится 2**32 = 4 294 967 296 вариантов. Много. Будут скучные варианты, которые всегда производят пустые или полные клетки, но вероятность наткнуться на них очень мала.

Вроде номр. Остаётся только повторить деление клеток ещё несколько раз, любуясь проявляющейся картинкой.

Туду: анимировать более плавно, не как сейчас.

https://bit.ly/3GSOjVz --&gt;
&lt;!-- ---


https://t.me/ivandianov/448

Воскрешаю иваноматы, может что-то прикольное из них выйдет.

Для них с помощью Стренджера и учебника по вебгл сделал мини-фреймворк. 

Главная фишка фреймворка — не нужны сборщики! Ни парсел, ни, боже упаси, вебпак, ни даже дино. Просто js файлы.

Кажется, что на побарывание систем сборки (написание конфигов, исправление ошибок с версиями и пр, пр, пр) у меня ушло столько же времени, сколько и на полезный код.

Как же приятно побыть дауншифтером: просто открываешь в браузере и просто работает. --&gt;</content>
	</entry>
	
	<entry xml:lang="ru">
		<title>Как въехать в трансформации пространства</title>
		<link href="https://ivandianov.com/ru/pretending/"/>
		<updated>2022-07-06T14:00:00Z</updated>
		<id>https://ivandianov.com/ru/pretending/</id>
		<content type="html">&lt;p&gt;В школе мы проходили графики разных функций, например, параболы: &lt;code&gt;y = x²&lt;/code&gt;. Я никак не мог понять, почему при увеличении x, например &lt;code&gt;y = (x + 1)²&lt;/code&gt; график сдвигается влево. Интуиция говорила, что должен вправо сдвигаться!&lt;/p&gt;
&lt;p&gt;Дальше хуже: оказалось, что при умножении икса &lt;code&gt;y = (2x)²&lt;/code&gt; график не растягивается вдоль оси x а наоборот, сужается.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ivandianov.com/assets/media/2022-07-06-14-33-35.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Если не верите, &lt;a href=&quot;https://www.desmos.com/calculator/plcsrckgof&quot;&gt;проверьте сами&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Когда начал копать шейдеры, оказалось, что школьные проблемы до сих пор не решены. Поэтому первый год я подбирал нужный оператор методом тыка: плюс не помог, окей, поставим минус.&lt;/p&gt;
&lt;p&gt;Сейчас, вроде, разобрался, сейчас расскажу.&lt;/p&gt;
&lt;p&gt;Возьмём шейдер, который рисует кружочек:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ivandianov.com/assets/media/2022-07-06-15-28-04.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-GLSL&quot;&gt;precision highp float;
uniform vec2 resolution;
out vec4 outColor;

void main(){
  vec2 uv=(gl_FragCoord.xy*2.-resolution)/resolution.y*2.; // find UV coordinates of a pixel
  outColor.rg+=fract(uv); // draw grid while space is not transformed yet
  outColor.b=1.; // nice colors!
  
  // TRANSFORMATIONS WILL BE HERE
  
  outColor+=step(length(uv),1.); // draw circle in transformed space
  // it&#39;s like pixel is saying “if my distance to the origin is less than 1, I go white”
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://bit.ly/3OP90VN&quot; :=&quot;&quot; class=&quot;caption&quot;&gt;bit.ly/3OP90VN&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Действительно, &lt;code&gt;uv*=2.;&lt;/code&gt; уменьшает картинку:&lt;/p&gt;
&lt;p :=&quot;&quot; class=&quot;caption&quot;&gt;&lt;img src=&quot;https://ivandianov.com/assets/media/2022-07-06-15-29-33.png&quot; alt=&quot;&quot;&gt;
&lt;a href=&quot;https://bit.ly/3PbJyK9&quot;&gt;https://bit.ly/3PbJyK9&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;а &lt;code&gt;uv/=2.;&lt;/code&gt; растягивает её:&lt;/p&gt;
&lt;p :=&quot;&quot; class=&quot;caption&quot;&gt;&lt;img src=&quot;https://ivandianov.com/assets/media/2022-07-06-15-34-52.png&quot; alt=&quot;&quot;&gt;
&lt;a href=&quot;https://bit.ly/3yKkCDU&quot;&gt;https://bit.ly/3yKkCDU&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Аналогично &lt;code&gt;uv.x += 1.;&lt;/code&gt;. сдвигает график влево, а &lt;code&gt;uv.x -= 1.&lt;/code&gt; — вправо. Где логика, где разум?&lt;/p&gt;
&lt;p&gt;На какое-то время я думал, что нашёл спасение в вот такой формулировке:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Когда мы трансформируем координаты, мы меняем не картинку а пространство. Например, если делаем &lt;code&gt;uv*=2.;&lt;/code&gt;, все изменения в пространстве начинают происходить в два раза быстрее, вот кружок и уменьшается.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Но пользоваться такой мыслью при программировании было сложно. Наконец придумалась более удобная:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Когда мы меняем координаты точки, она начинает притворяться другой точкой с новыми координатами.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Допустим, пиксель. Вычисляем его uv координаты и получаем (0, 0.5). После умножения каждого компонента на 2 этот пиксель притворится точкой (0, 1), а это правый край нашей единичной окружности. Значит наш пиксель этот край и покажет.&lt;/p&gt;
&lt;p&gt;Получилось, что край окружности стал в два раза ближе к центру, чем был бы без трансформации.&lt;/p&gt;
&lt;p&gt;Упражнения:
Возьмите исходный шейдер с кружком и добавьте трансформацию, чтобы окружность:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;сдвинулась вниз на 1.;&lt;/li&gt;
&lt;li&gt;скукожилась по оси y в 4 раза;&lt;/li&gt;
&lt;li&gt;стала с радиусом 0.5 и с центром в (0.5, 0.5)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;Что думаете про такой способ думать о трансформациях пространства? Что осталось непонятным? А может, вы знаете, как проще трансформации объяснить? Расскажите тут в комментариях или напишите &lt;a href=&quot;https://t.me/ivan_dianov&quot;&gt;мне в телеграм&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;</content>
	</entry>
	
	<entry xml:lang="en">
		<title>The concept of ID in shaders</title>
		<link href="https://ivandianov.com/concept-of-id/"/>
		<updated>2021-09-02T09:59:00Z</updated>
		<id>https://ivandianov.com/concept-of-id/</id>
		<content type="html">&lt;p&gt;&lt;img src=&quot;https://ivandianov.com/assets/media/2021-09-03-10-49-32.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;I&#39;ll tell you about the concept of id in shaders and show you what it is for. If you&#39;re not familiar with shaders, start with &lt;a href=&quot;https://thebookofshaders.com/&quot;&gt;The Book of Shaders&lt;/a&gt; — the best tutorial on the subject.&lt;/p&gt;
&lt;p&gt;The code in the article is for &lt;a href=&quot;https://bit.ly/3Jl0Gdj&quot;&gt;twigl.app&lt;/a&gt; editor in “geekest (es300)” mode.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;The purpose of the trick is to make the picture more complicated and gain control over each of the tiny parts.&lt;/p&gt;
&lt;p&gt;I will first outline the algorithm, and then illustrate the trick with code and pictures. The algorithm is as follows:&lt;/p&gt;
&lt;ol start=&quot;0&quot;&gt;
&lt;li&gt;Set all pixels to the same initial id. For example, let it be &lt;code&gt;1&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Split pixels into groups. The group into which the pixel falls depends on its previous id and an additional criteria.&lt;/li&gt;
&lt;li&gt;Repeat step 1 several times, each time increasing the number of id&#39;s and complicating the picture.&lt;/li&gt;
&lt;li&gt;Use the id to calculate color, texture, animation speed, whatever.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;There are two ways to calculate the id: accurate and chaotic. Let&#39;s test both of them:&lt;/p&gt;
&lt;h3&gt;Accurate segmentation&lt;/h3&gt;
&lt;p&gt;Suppose we want to divide the image into three parts each time. We also want to ensure that none of the two segments have the same id&#39;s, no matter how many of them there are.&lt;/p&gt;
&lt;p&gt;There is a way to do this. The first time we split pixels into segments, we give each segment ids from 0 to 1, so that they are equidistant from each other: &lt;code&gt;id=0&lt;/code&gt;, &lt;code&gt;id=1/3&lt;/code&gt;, &lt;code&gt;id=2/3&lt;/code&gt;. The next time we split each segment into three more segments, we add smaller values to their ids: &lt;code&gt;id=id+0&lt;/code&gt;, &lt;code&gt;id=id+1/9&lt;/code&gt;, &lt;code&gt;id=id+2/9&lt;/code&gt;.
Each next division should change ids on a smaller and smaller value.&lt;/p&gt;
&lt;p&gt;With this algorithm, we can guarantee the uniqueness of each and every id, hooray. Let&#39;s try to repeat the idea in code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vec2 uv = FC.xy/r;

float id=0., k=1.;

uv=fract(uv)*3.;

id+=floor(uv.x)/3.; // split into three columns
k/=3.;
id+=k*floor(uv.y)/3.; // split into three rows
k/=3.;

uv=fract(uv)*3.;

id+=k*floor(uv.x)/3.; // split into three columns
k/=3.;
id+=k*floor(uv.y)/3.;  // split into three rows
k/=3.;

o+=id;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://ivandianov.com/assets/media/2021-09-02-12-03-24.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;We see that each segment has its own unique color, but we have to use the multiplier k, which is not always convenient. A chaotic approach is often sufficient.&lt;/p&gt;
&lt;h3&gt;Chaotic segmentation&lt;/h3&gt;
&lt;p&gt;Last time we carefully added three different values to different subsegments of each segment.&lt;/p&gt;
&lt;p&gt;Now we are also going to use the previous value of id to find subsegment ids. The difference is in the function we use: now we use a pseudo-random one, that takes any number (seed) as input and returns a random number from 0 to 1. The trick is that for the same argument (seed) it returns the same random value.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;↓ subsegment id              ↓ segment id
id = rnd( floor(uv.y) / 3. + id )
         └─────────────────────┘  seed
         └────────────────┘ thing, 
         that makes seed different
         for different parts of the segment
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-glsl&quot;&gt;#define rnd(x) fsnoise(vec2(x))
vec2 uv = FC.xy/r;

float id=0.;

uv=fract(uv)*3.;

id=rnd(floor(uv.x)/3.);  // split into three columns
id=rnd(floor(uv.y)/3.+id);  // split into three rows

uv=fract(uv)*3.;

id=rnd(floor(uv.x)/3.+id);  // split into three columns
id=rnd(floor(uv.y)/3.+id);  // split into three rows

o+=id;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://ivandianov.com/assets/media/2021-09-02-12-10-49.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;We can see that the grid is chaotic, maybe some regions will have the same IDs, but unlikely.&lt;/p&gt;
&lt;h2&gt;Segments variability&lt;/h2&gt;
&lt;p&gt;Fasten your seat belts. Now for the coolest part. You can make the settings for subsequent splits dependent on their current id!&lt;/p&gt;
&lt;p&gt;For example, here the number of splits can vary depending on the id:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-glsl&quot;&gt;#define rnd(x) fsnoise(vec2(x)+.1)
vec2 uv = FC.xy/r;

float id=0.;

uv=fract(uv)*3.;

id=rnd(floor(uv.x)/3.);  // split into three columns
id=rnd(floor(uv.y)/3.+id);  // split into three rows

uv=fract(uv)*3.;

//                 ↓ the smaller id, the denser the pattern
id=rnd(floor(uv.x/id)/3.+id);  // split into three columns
id=rnd(floor(uv.y/id)/3.+id);  // split into three rows

o+=id;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://ivandianov.com/assets/media/2021-09-03-10-23-52.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;You can repeat and repeat the split as much as you like. Or better add a loop, so as not to duplicate the code for each iteration.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-glsl&quot;&gt;#define rnd(x) fsnoise(vec2(x)+.1)
vec2 uv = FC.xy/r;

float id=1.;

for(int i=0;i&amp;lt;3;i++){
  uv=fract(uv)*3.;
  id=rnd(floor(uv.x/id)/3.+id);
  id=rnd(floor(uv.y/id)/3.+id);
}

o+=id;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://ivandianov.com/assets/media/2021-09-03-10-28-11.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;If we increase the number of iterations to 5, there will be only noise left:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ivandianov.com/assets/media/2021-09-03-10-29-17.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;We can make the number of loop repetitions dependent on the id as well!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-glsl&quot;&gt;#define rnd(x) fsnoise(vec2(x)+.1)
vec2 uv = FC.xy/r;

float id=1.;

for(int i=0;i&amp;lt;5;i++){
  uv=fract(uv)*3.;
  id=rnd(floor(uv.x/id)/3.+id);
  id=rnd(floor(uv.y/id)/3.+id);
  if(i&amp;gt;0 &amp;amp;&amp;amp; id&amp;lt;.5) break;
}

o+=id;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://ivandianov.com/assets/media/2021-09-03-10-31-37.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;The picture went dark, it&#39; s something of a survivorship bias. We exit the loop when the id is less than .5, and those pixels get a darker color. This can be fixed by replacing the &lt;code&gt;id &amp;lt; .5&lt;/code&gt; condition with &lt;code&gt;rnd(id) &amp;lt; .5&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ivandianov.com/assets/media/2021-09-03-10-33-51.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;And now that the technique is mastered, you can go and have fun all the way!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-glsl&quot;&gt;#define rnd(x) fsnoise(vec2(x)+.1)
#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))

vec2 uv = (FC.xy*2.-r)/r.x;

float id=floor(length(uv)*8.)+1.;

for(int i=0;i&amp;lt;5;i++){
  if(i&amp;gt;0 &amp;amp;&amp;amp; rnd(id)&amp;lt;.5) break;
  uv*=rot(PI/4.+t*(rnd(id)-.5));
  uv=fract(uv)*3.;
  id=rnd(floor(uv.x/id)/3.+id);
  id=rnd(floor(uv.y/id)/3.+id);
}

o+=id;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://ivandianov.com/assets/media/2021-09-03-10-49-32.png&quot; alt=&quot;&quot;&gt;
&lt;a href=&quot;https://bit.ly/3BE99o9&quot;&gt;Check out the link&lt;/a&gt;, it spins! And, surely, the rotation speed of each piece depends on its id :-)&lt;/p&gt;</content>
	</entry>
	
	<entry xml:lang="ru">
		<title>Концепт ID в шейдерах</title>
		<link href="https://ivandianov.com/ru/concept-of-id/"/>
		<updated>2021-09-02T09:59:00Z</updated>
		<id>https://ivandianov.com/ru/concept-of-id/</id>
		<content type="html">&lt;p&gt;&lt;img src=&quot;https://ivandianov.com/assets/media/2021-09-03-10-49-32.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Расскажу про концепцию идентификатора в шейдерах и покажу, на что она способна. Если вы не знакомы с шейдерами и вам ничего непонятно, начните с &lt;a href=&quot;https://thebookofshaders.com/&quot;&gt;книги шейдеров&lt;/a&gt; — лучшего учебника по сабжу.&lt;/p&gt;
&lt;p&gt;Примеры кода из статьи можно запустить &lt;a href=&quot;https://bit.ly/3Jl0Gdj&quot;&gt;в клёвом редакторе Твигл&lt;/a&gt;, в режиме geekest (es300)&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Цель приёма — усложнить картинку и получить контроль над каждым из крошечных участков.&lt;/p&gt;
&lt;p&gt;Сперва опишу алгоритм, потом проиллюстрирую приём кодом и картинками. Алгоритм такой:&lt;/p&gt;
&lt;ol start=&quot;0&quot;&gt;
&lt;li&gt;Задаём всем пикселям одинаковый начальный id. Например, пусть будет равен единице.&lt;/li&gt;
&lt;li&gt;Делим пиксели на группы. То, в какую группу попадёт пиксель, зависит от его id, полученному на предыдущем шаге. Получаем новые идентификаторы.&lt;/li&gt;
&lt;li&gt;Повторяем пункт 1 несколько раз, каждый раз увеличивая число возможных id и усложняя картинку.&lt;/li&gt;
&lt;li&gt;Используем id для расчёта цвета, текстуры, скорости анимации, чего угодно.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Есть два способа вычислять id: аккуратный и хаотичный. Затестим оба:&lt;/p&gt;
&lt;h3&gt;Аккуратный способ сегментации&lt;/h3&gt;
&lt;p&gt;Допустим, мы хотим каждый раз делить картинку на три части. А ещё допустим, что мы аккуратные и хотим гарантировать, что ни у каких двух сегментов айдишники не совпадут, сколько бы их ни было.&lt;/p&gt;
&lt;p&gt;Есть способ добиться желаемого: при первом делении раздадим каждой части айдишники от 0 до 1, чтобы они были «на одинаковом расстоянии» друг от друга:  &lt;code&gt;id = 0&lt;/code&gt;, &lt;code&gt;id = 1/3&lt;/code&gt;, &lt;code&gt;id = 2/3&lt;/code&gt;. При следующем делении каждой трети ещё на три части, прибавим к уже найденным айдишникам уменьшенные значения: &lt;code&gt;id = id + 0&lt;/code&gt;, &lt;code&gt;id = id + 1/9&lt;/code&gt;, &lt;code&gt;id = id + 2/9&lt;/code&gt;.
Каждое следующее деление должно менять айдишник с меньшим и меньшим шагом.&lt;/p&gt;
&lt;p&gt;При таком алгоритме мы можем гарантировать уникальность каждого айдишника, ура. Попробуем повторить идею в коде:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vec2 uv = FC.xy/r;

float id=0., k=1.;

uv=fract(uv)*3.;

id+=floor(uv.x)/3.; // делим на три столбца
k/=3.;
id+=k*floor(uv.y)/3.; // делим на три строки
k/=3.;

uv=fract(uv)*3.;

id+=k*floor(uv.x)/3.; // делим на три столбца
k/=3.;
id+=k*floor(uv.y)/3.;  // делим на три строки
k/=3.;

o+=id;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://ivandianov.com/assets/media/2021-09-02-12-03-24.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Мы видим, что каждый сегмент имеет свой уникальный цвет, но для этого приходится использовать мультипликатор k, что не всегда удобно. Часто бывает достаточно хаотического подхода.&lt;/p&gt;
&lt;h3&gt;Хаотический способ сегментации&lt;/h3&gt;
&lt;p&gt;В прошлый раз мы аккуратно прибаляли к разным частям сегмента три разных значения.&lt;/p&gt;
&lt;p&gt;Здесь мы также используем предыдущее значение айдишника сегмента, чтобы найти айдишкики трёх кусочков. Разница в используемой функции, тут это псевдорандом: функция, которая принимает на вход любое число (seed) и возвращает случайное число от 0 до 1. Прикол в том, что для одного и того же аргумента seed она возвращает одно и то же случайное значение.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;↓ id подсегмента             ↓ id сегмента
id = rnd( floor(uv.y) / 3. + id )
         └─────────────────────┘  seed
         └────────────────┘ штука,
         которая делает seed разным
         для разных частей сегмента
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Код:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-glsl&quot;&gt;#define rnd(x) fsnoise(vec2(x))
vec2 uv = FC.xy/r;

float id=0.;

uv=fract(uv)*3.;

id=rnd(floor(uv.x)/3.);  // делим на три столбца
id=rnd(floor(uv.y)/3.+id);  // делим на три строки

uv=fract(uv)*3.;

id=rnd(floor(uv.x)/3.+id);  // делим на три столбца
id=rnd(floor(uv.y)/3.+id);  // делим на три строки

o+=id;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://ivandianov.com/assets/media/2021-09-02-12-10-49.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Видим, что сетка получается хаотичной, может у каких-то регионов айдишники и совпадут, но вероятность маленькая.&lt;/p&gt;
&lt;h2&gt;Изменчивость сегментов&lt;/h2&gt;
&lt;p&gt;Пристегните ремни. Сейчас самое крутое. Можно сделать настройки последующих разбиений зависимыми от текущего айдишника. Буум!&lt;/p&gt;
&lt;p&gt;Например, тут число разбиений может варьировать в зависимости от айди:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-glsl&quot;&gt;#define rnd(x) fsnoise(vec2(x)+.1)
vec2 uv = FC.xy/r;

float id=0.;

uv=fract(uv)*3.;

id=rnd(floor(uv.x)/3.);  // делим на три столбца
id=rnd(floor(uv.y)/3.+id);  // делим на три строки

uv=fract(uv)*3.;

//                 ↓ чем меньше, тем гуще
id=rnd(floor(uv.x/id)/3.+id);  // делим на три столбца
id=rnd(floor(uv.y/id)/3.+id);  // делим на три строки

o+=id;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://ivandianov.com/assets/media/2021-09-03-10-23-52.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Можно повторять и повторять разбиение сколько угодно. Или лучше добавить цикл, чтобы не копипастить.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-glsl&quot;&gt;#define rnd(x) fsnoise(vec2(x)+.1)
vec2 uv = FC.xy/r;

float id=1.;

for(int i=0;i&amp;lt;3;i++){
  uv=fract(uv)*3.;
  id=rnd(floor(uv.x/id)/3.+id);
  id=rnd(floor(uv.y/id)/3.+id);
}

o+=id;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://ivandianov.com/assets/media/2021-09-03-10-28-11.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Если увеличить число повторов до 5, останется один мусор:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ivandianov.com/assets/media/2021-09-03-10-29-17.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Но ведь мы можем сделать число повторов цикла также зависимым от id!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-glsl&quot;&gt;#define rnd(x) fsnoise(vec2(x)+.1)
vec2 uv = FC.xy/r;

float id=1.;

for(int i=0;i&amp;lt;5;i++){
  uv=fract(uv)*3.;
  id=rnd(floor(uv.x/id)/3.+id);
  id=rnd(floor(uv.y/id)/3.+id);
  if(i&amp;gt;0 &amp;amp;&amp;amp; id&amp;lt;.5) break;
}

o+=id;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://ivandianov.com/assets/media/2021-09-03-10-31-37.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Картинка потемнела, это что-то вроде ошибки выжившего. Мы вылетаем из цикла, когда айдишник меньше .5, а у таких цвет получается тёмным. Это исправляется заменой условия &lt;code&gt;id &amp;lt; .5&lt;/code&gt; на &lt;code&gt;rnd(id) &amp;lt; .5&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ivandianov.com/assets/media/2021-09-03-10-33-51.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;А теперь, когда приём освоен, можно идти и веселиться по-полной.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-glsl&quot;&gt;#define rnd(x) fsnoise(vec2(x)+.1)
#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))

vec2 uv = (FC.xy*2.-r)/r.x;

float id=floor(length(uv)*8.)+1.;

for(int i=0;i&amp;lt;5;i++){
  if(i&amp;gt;0 &amp;amp;&amp;amp; rnd(id)&amp;lt;.5) break;
  uv*=rot(PI/4.+t*(rnd(id)-.5));
  uv=fract(uv)*3.;
  id=rnd(floor(uv.x/id)/3.+id);
  id=rnd(floor(uv.y/id)/3.+id);
}

o+=id;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://ivandianov.com/assets/media/2021-09-03-10-49-32.png&quot; alt=&quot;&quot;&gt;
&lt;a href=&quot;https://bit.ly/3BE99o9&quot;&gt;Посмотрите ссылку&lt;/a&gt;, оно ещё и крутится! Скорость вращения каждого кусочка, конечно же, зависит от его айдишника.&lt;/p&gt;</content>
	</entry>
	
</feed>