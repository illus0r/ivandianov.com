---
title: Переопределение пространства
date: 2022-07-06 11:58:00
progress: 1
---

<!-- Офигенная техника, прямо прусь. Чем больше с ней экспериментирую, тем больше прикольных ходов появляется.

Что общего между этими строчками?

p=p.zxy;
p=vec3(length(p.yx),atan(p.y,p.x)/6.28,p.z);
p=vec3(noise(p),noise(p+1.),noise(p+2.));

Правильно, они все сложные и выносят мозг. По

На самом деле мы вскрылы фундаментальный слой понимания СДФ и сейчас дойдём до просветления.

Потому что весь смысл СДФ заключается в простой штуке: vec3 → float. Это просто способ получения одномерного вектора из многомерного. Неважно, происходит это при постепенном уменьшении размерности или мы схлопываем все три размерности в одну в самом конце.

Допустим мы написали СДФ, который рисует цилиндр, идущий вдоль оси y -->




<!-- Трансформация пространства — замена компонентов вектора на произвольный СДФ. Допустим, у нас есть две функции, делающие цилиндры, первая cylSmall рисует тонкий цилиндр вдоль оси y length(p.xz)-.5, другая cylLarge — толстый цилиндр вдоль оси z: length(p.xy)-2.;

Переопределением пространства будет трансформация, которая использует один из этих сдф вместо одного из компонентов вектора: -->

Для переопределения оси может использоваться как только её прошлое значение p.x = p.x - 1.; Так и более сложная формула, зависящая от нескольких компонентов вектора: p.x = length(p.xyz) - 4.;

Иногда надо преобразовать сразу два компонента вектора. Например для перехода в полярные координаты надо чтобы в p.x попало length(p.xy)-4. а в p.y оказалось atan(p.y,p.x)/(PI*2.). Причём обе эти формулы зависят и от p.y и от p.x, значит надо вычислить оба этих значения одновременно. Иначе изменение одного компонента p, скажем, p.x повлияет на последующее вычисление p.y. К счастью в GLSL можно выполнить две трансформации одновременно:

p.xy = vec2(length(p.xy)-4., atan(p.y,p.x)/(PI*2.));

p.x = cylLarge(p);
return cylSmall(p);
https://bit.ly/3NNfiUT

Мы как бы говорим: изменение значения cylLarge теперь претваряется изменением p.x;

