<!DOCTYPE html>
<html><head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>The concept of ID in shaders</title>
    <link async="" rel="stylesheet" type="text/css" href="../../assets/css/styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin=""> 
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@0,400;0,700;1,400;1,600&amp;display=swap" rel="stylesheet">

</head>
  <body>
    
    <header>
  <div class="nav-menu">
    <div class="logo">
        Ivan Dianov
    </div>
        
    

    
      
    
      
      
      
        
        
      <a class="nav-item" href="/ru/concept-of-id/">
        Ru
      </a>
      
      
    
      
      
      
        
      
    
      
      
      
        
      
    
      
    
      
    
      
    
      
    
      
      
      
        
      
    
      
      
      
        
      
    
      
      
      
        
      
    

    
    

    
      
        
        <a class="nav-item" href="/tutor/">
          Tutor
        </a>
        
      
    
      
        
        <a class="nav-item" href="/about/">
          About
        </a>
        
      
    
      
    
      
        
        <a class="nav-item" href="/works/">
          Works
        </a>
        
      
    
      
    
      
        
        <a class="nav-item" href="/">
          Blog
        </a>
        
      
    
      
    
  </div>
</header>
    <main role="main" class="wrap prose">
      <article class="text" role="main">
    <div class="post-header">
    <h1 class="post-name">The concept of ID in shaders</h1>
    </div>
    <section class="post-content">
        <p><img src="/assets/media/2021-09-03-10-49-32.png" alt=""></p>
<p>I'll tell you about the concept of id in shaders and show you what it is for. If you're not familiar with shaders, start with <a href="https://thebookofshaders.com/">The Book of Shaders</a> — the best tutorial on the subject.</p>
<p>The code in the article is for <a href="https://bit.ly/3Jl0Gdj">twigl.app</a> editor in “geekest (es300)” mode.</p>
<hr>
<p>The purpose of the trick is to make the picture more complicated and gain control over each of the tiny parts.</p>
<p>I will first outline the algorithm, and then illustrate the trick with code and pictures. The algorithm is as follows:</p>
<ol start="0">
<li>Set all pixels to the same initial id. For example, let it be <code>1</code>.</li>
<li>Split pixels into groups. The group into which the pixel falls depends on its previous id and an additional criteria.</li>
<li>Repeat step 1 several times, each time increasing the number of id's and complicating the picture.</li>
<li>Use the id to calculate color, texture, animation speed, whatever.</li>
</ol>
<p>There are two ways to calculate the id: accurate and chaotic. Let's test both of them:</p>
<h3>Accurate segmentation</h3>
<p>Suppose we want to divide the image into three parts each time. We also want to ensure that none of the two segments have the same id's, no matter how many of them there are.</p>
<p>There is a way to do this. The first time we split pixels into segments, we give each segment ids from 0 to 1, so that they are equidistant from each other: <code>id=0</code>, <code>id=1/3</code>, <code>id=2/3</code>. The next time we split each segment into three more segments, we add smaller values to their ids: <code>id=id+0</code>, <code>id=id+1/9</code>, <code>id=id+2/9</code>.
Each next division should change ids on a smaller and smaller value.</p>
<p>With this algorithm, we can guarantee the uniqueness of each and every id, hooray. Let's try to repeat the idea in code:</p>
<pre><code>vec2 uv = FC.xy/r;

float id=0., k=1.;

uv=fract(uv)*3.;

id+=floor(uv.x)/3.; // split into three columns
k/=3.;
id+=k*floor(uv.y)/3.; // split into three rows
k/=3.;

uv=fract(uv)*3.;

id+=k*floor(uv.x)/3.; // split into three columns
k/=3.;
id+=k*floor(uv.y)/3.;  // split into three rows
k/=3.;

o+=id;
</code></pre>
<p><img src="/assets/media/2021-09-02-12-03-24.png" alt=""></p>
<p>We see that each segment has its own unique color, but we have to use the multiplier k, which is not always convenient. A chaotic approach is often sufficient.</p>
<h3>Chaotic segmentation</h3>
<p>Last time we carefully added three different values to different subsegments of each segment.</p>
<p>Now we are also going to use the previous value of id to find subsegment ids. The difference is in the function we use: now we use a pseudo-random one, that takes any number (seed) as input and returns a random number from 0 to 1. The trick is that for the same argument (seed) it returns the same random value.</p>
<pre><code>↓ subsegment id              ↓ segment id
id = rnd( floor(uv.y) / 3. + id )
         └─────────────────────┘  seed
         └────────────────┘ thing, 
         that makes seed different
         for different parts of the segment
</code></pre>
<p>Code:</p>
<pre><code class="language-glsl hljs"><span class="hljs-meta">#define rnd(x) fsnoise(vec2(x))</span>
<span class="hljs-type">vec2</span> uv = FC.xy/r;

<span class="hljs-type">float</span> id=<span class="hljs-number">0.</span>;

uv=<span class="hljs-built_in">fract</span>(uv)*<span class="hljs-number">3.</span>;

id=rnd(<span class="hljs-built_in">floor</span>(uv.x)/<span class="hljs-number">3.</span>);  <span class="hljs-comment">// split into three columns</span>
id=rnd(<span class="hljs-built_in">floor</span>(uv.y)/<span class="hljs-number">3.</span>+id);  <span class="hljs-comment">// split into three rows</span>

uv=<span class="hljs-built_in">fract</span>(uv)*<span class="hljs-number">3.</span>;

id=rnd(<span class="hljs-built_in">floor</span>(uv.x)/<span class="hljs-number">3.</span>+id);  <span class="hljs-comment">// split into three columns</span>
id=rnd(<span class="hljs-built_in">floor</span>(uv.y)/<span class="hljs-number">3.</span>+id);  <span class="hljs-comment">// split into three rows</span>

o+=id;
</code></pre>
<p><img src="/assets/media/2021-09-02-12-10-49.png" alt=""></p>
<p>We can see that the grid is chaotic, maybe some regions will have the same IDs, but unlikely.</p>
<h2>Segments variability</h2>
<p>Fasten your seat belts. Now for the coolest part. You can make the settings for subsequent splits dependent on their current id!</p>
<p>For example, here the number of splits can vary depending on the id:</p>
<pre><code class="language-glsl hljs"><span class="hljs-meta">#define rnd(x) fsnoise(vec2(x)+.1)</span>
<span class="hljs-type">vec2</span> uv = FC.xy/r;

<span class="hljs-type">float</span> id=<span class="hljs-number">0.</span>;

uv=<span class="hljs-built_in">fract</span>(uv)*<span class="hljs-number">3.</span>;

id=rnd(<span class="hljs-built_in">floor</span>(uv.x)/<span class="hljs-number">3.</span>);  <span class="hljs-comment">// split into three columns</span>
id=rnd(<span class="hljs-built_in">floor</span>(uv.y)/<span class="hljs-number">3.</span>+id);  <span class="hljs-comment">// split into three rows</span>

uv=<span class="hljs-built_in">fract</span>(uv)*<span class="hljs-number">3.</span>;

<span class="hljs-comment">//                 ↓ the smaller id, the denser the pattern</span>
id=rnd(<span class="hljs-built_in">floor</span>(uv.x/id)/<span class="hljs-number">3.</span>+id);  <span class="hljs-comment">// split into three columns</span>
id=rnd(<span class="hljs-built_in">floor</span>(uv.y/id)/<span class="hljs-number">3.</span>+id);  <span class="hljs-comment">// split into three rows</span>

o+=id;
</code></pre>
<p><img src="/assets/media/2021-09-03-10-23-52.png" alt=""></p>
<p>You can repeat and repeat the split as much as you like. Or better add a loop, so as not to duplicate the code for each iteration.</p>
<pre><code class="language-glsl hljs"><span class="hljs-meta">#define rnd(x) fsnoise(vec2(x)+.1)</span>
<span class="hljs-type">vec2</span> uv = FC.xy/r;

<span class="hljs-type">float</span> id=<span class="hljs-number">1.</span>;

<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++){
  uv=<span class="hljs-built_in">fract</span>(uv)*<span class="hljs-number">3.</span>;
  id=rnd(<span class="hljs-built_in">floor</span>(uv.x/id)/<span class="hljs-number">3.</span>+id);
  id=rnd(<span class="hljs-built_in">floor</span>(uv.y/id)/<span class="hljs-number">3.</span>+id);
}

o+=id;
</code></pre>
<p><img src="/assets/media/2021-09-03-10-28-11.png" alt=""></p>
<p>If we increase the number of iterations to 5, there will be only noise left:</p>
<p><img src="/assets/media/2021-09-03-10-29-17.png" alt=""></p>
<p>We can make the number of loop repetitions dependent on the id as well!</p>
<pre><code class="language-glsl hljs"><span class="hljs-meta">#define rnd(x) fsnoise(vec2(x)+.1)</span>
<span class="hljs-type">vec2</span> uv = FC.xy/r;

<span class="hljs-type">float</span> id=<span class="hljs-number">1.</span>;

<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++){
  uv=<span class="hljs-built_in">fract</span>(uv)*<span class="hljs-number">3.</span>;
  id=rnd(<span class="hljs-built_in">floor</span>(uv.x/id)/<span class="hljs-number">3.</span>+id);
  id=rnd(<span class="hljs-built_in">floor</span>(uv.y/id)/<span class="hljs-number">3.</span>+id);
  <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span> &amp;&amp; id&lt;<span class="hljs-number">.5</span>) <span class="hljs-keyword">break</span>;
}

o+=id;
</code></pre>
<p><img src="/assets/media/2021-09-03-10-31-37.png" alt=""></p>
<p>The picture went dark, it' s something of a survivorship bias. We exit the loop when the id is less than .5, and those pixels get a darker color. This can be fixed by replacing the <code>id &lt; .5</code> condition with <code>rnd(id) &lt; .5</code>.</p>
<p><img src="/assets/media/2021-09-03-10-33-51.png" alt=""></p>
<p>And now that the technique is mastered, you can go and have fun all the way!</p>
<pre><code class="language-glsl hljs"><span class="hljs-meta">#define rnd(x) fsnoise(vec2(x)+.1)</span>
<span class="hljs-meta">#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))</span>

<span class="hljs-type">vec2</span> uv = (FC.xy*<span class="hljs-number">2.</span>-r)/r.x;

<span class="hljs-type">float</span> id=<span class="hljs-built_in">floor</span>(<span class="hljs-built_in">length</span>(uv)*<span class="hljs-number">8.</span>)+<span class="hljs-number">1.</span>;

<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++){
  <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span> &amp;&amp; rnd(id)&lt;<span class="hljs-number">.5</span>) <span class="hljs-keyword">break</span>;
  uv*=rot(PI/<span class="hljs-number">4.</span>+t*(rnd(id)<span class="hljs-number">-.5</span>));
  uv=<span class="hljs-built_in">fract</span>(uv)*<span class="hljs-number">3.</span>;
  id=rnd(<span class="hljs-built_in">floor</span>(uv.x/id)/<span class="hljs-number">3.</span>+id);
  id=rnd(<span class="hljs-built_in">floor</span>(uv.y/id)/<span class="hljs-number">3.</span>+id);
}

o+=id;
</code></pre>
<p><img src="/assets/media/2021-09-03-10-49-32.png" alt="">
<a href="https://bit.ly/3BE99o9">Check out the link</a>, it spins! And, surely, the rotation speed of each piece depends on its id :-)</p>

    </section>
</article>

<script src="https://utteranc.es/client.js" repo="illus0r/ivandianov.com" issue-term="pathname" label="blog-comment" theme="github-light" crossorigin="anonymous" async="">
</script>
    </main>

    <footer>
  <section class="copyright">
    © <a href="/">Ivan Dianov</a> 2021—2022 ·
    <a href="https://twitter.com/i_dianov">Twitter</a>
    · <a href="https://objkt.com/profile/ivandianov/created">Objkt</a>
    
    
  </section>
</footer>

	
</body></html>